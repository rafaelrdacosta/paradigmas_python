1. Estruturas de decisão
    - if
    Ex:
    idade = eval(input('Informe a idade da criança: \n'))
    if idade < 5:
        print('A criança deve ser vacinada contra a gripe.')
        print('Procure o posto de saúde mais próximo.')

    - if/else
    Ex:
    idade = eval(input('Informe a idade da criança: \n'))
    if idade < 5:
        print('A criança deve ser vacinada contra a gripe.')
        print('Procure o posto de saúde mais próximo.')
    else:
        print('A vacinação só ocorrerá daqui a 3 meses.')
        print('Informe-se novamente neste prazo.')

    - elif:  O elif nos permite testar várias condições de forma sequencial.
    Ex:
    idade = eval(input('Informe a idade da criança: \n'))
    if idade < 5:
        print('A criança deve ser vacinada contra a gripe.')
        print('Procure o posto de saúde mais próximo.')
    elif idade == 5:
        print('A vacina estará disponível em breve.')
        print('Aguarde as próximas informações.')
    else:
        print('A vacinação só ocorrerá daqui a 3 meses.')
        print('Informe-se novamente neste prazo.')
    print('Cuide da saúde sempre. Até a próxima.')

2. Estrutura de repetição for
    a. As listas do tipo range()
        - método range(): Python cria uma sequência de nr inteiros.
        1) Simples
        Ex: range(3)  #Cria a sequência (0, 1, 2)

        2) Não iniciada em zero
        Exclusive o fim dos parâmetros
        Ex: range(2, 7) #Sequência: (2, 3, 4, 5, 6)

        3) Indicando início, fim e passo
        Ex: range(2, 9, 3) #Sequência: (2, 5, 8)

    b. Sintaxe estrutura for

    for <variável> in <sequência>:
        Bloco que será repetido para todos os itens da sequência
    Instrução fora do for

    Exemplos:
    #saída: 2, 5, 8
    for item in range(2, 9, 3):
        print(item)

    #saída: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
    for numero in range(11):
        print(numero)

    c. O laço for cum uma string
    Exemplo:
    nome = input("Entre com seu nome: \n")
    for letra in nome:
        print(letra)

    d. Uso do laço for em listas
    - Listas são mutáveis, podem ser alteradas após a criação
    - São definidas por [] e os elementos separados por vírgulas

    Exemplo:
    nomes = ['Laura', 'Lis', 'Guilherme', 'Enzo', 'Arthur']
    for nome in nomes:
        print(nome)

3. Estrutura de repetiçaõ while e instruçoes auxiliares
    a. Sintaxe
    while condição:
        bloco_de_codigo

    b. O laço while infinito
    while True:
        bloco_de_codigo

    c. A instrução break
    - Interrompe as repetiçoes dos laços for e while
    Ex:
    while True:
       print('loop')
       palavra = input('Entre com uma palavra:')
       if palavra == 'sair':
          break
    print('Você digitou sair e agora está fora do laço')

    d. A instrução continue
    - Pula a iteração atual do laço e passa para próxima iteração.
    Exemplo:
    for num in range(1, 11):
        if num == 5:
            continue
        else:
            print(num)
    print('Laço encerrado')

    e. A instrução pass
    - É usada como um marcador de posição.
    - Ela é útil quando quer escrever uma estrutura que naõ faz nada.
    Exemplo:
    for num in range(1, 11):
        if num % 2 == 0:
            pass
        else:
            print(num)
    print('Laço encerrado')

4. Tipos de dados sequenciais e dicionário
    a. Tipos sequenciais

    1) Listas
        a) São sequências mutáveis, normalmente armazena itens homogêneos
        b) Lista vazia: []
        c) Maneiras de criar listas:
            (1) Usando colchetes e separa os itens por vírgulas: [a, b,c]
            (2) List comprehension: [x for x in iterable]
                Ex (ex055):
                Com loop tradicional:
                numeros = [1, 2, 3, 4]
                dobro = []
                for x in numeros:
                    dobro.append(x * 2)

                Com List Comprehension:
                dobro = [x * 2 for x in numeros]

                Adicionando filtros
                Ex:
                numeros = range(10)
                pares = [x for x in numeros if x % 2 == 0]
                # Resultado: [0, 2, 4, 6, 8]

                Usando condicionais no valor
                status = ["Par" if x % 2 == 0 else "Ímpar" for x in range(5)]
                # Resultado: ['Par', 'Ímpar', 'Par', 'Ímpar', 'Par']

            (3) list() ou list(iterable): usando o construtor do tipo list
                - list() - criando uma lista vazia
                Ex:
                minha_lista = list()
                print(minha_lista) #saída: []

                - list(iterable): convertendo dados
                    Quando você passa um iterável (qualquer objeto que você possa percorrer,
            como strings, tuplas, conjuntos ou dicionários), o Python cria uma lista contendo
            os elementos desse objeto.
                    Ex:
                    letras = list("Python")
                    print(letras)  # Saída: ['P', 'y', 't', 'h', 'o', 'n']

                    minha_tupla = (10, 20, 30)
                    lista_nova = list(minha_tupla)
                    lista_nova.append(40) # Agora é possível modificar

                    meu_dict = {'a': 1, 'b': 2}
                    chaves = list(meu_dict)
                    print(chaves)  # Saída: ['a', 'b']

    2) Tuplas
        a) São sequências imutáveis, usada para armazenar itens heterogêneos.
        b) Maneiras de criar uma tupla
            (1) tupla vazia: ()
            (2) separando os itens por vírgulas: a, b, c ou (a, b, c)
            (3) tuple() ou tuple(iterable)
                - método tuple(): criando uma tupla vazia
                Ex:
                vazia = tuple()
                print(vazia)  # Saída: ()

                - tuple(iterable): convertendo para imutável
                minha_lista = [1, 2, 3]
                minha_tupla = tuple(minha_lista)
                # minha_tupla.append(4)  # Isso causaria um AttributeError

                letras = tuple("Python")
                print(letras)  # Saída: ('P', 'y', 't', 'h', 'o', 'n')

        c) A Armadilha da Tupla de um Único Elemento

        Ao usar literais, o Python pode se confundir. O construtor tuple()
ajuda a evitar erros de sintaxe comuns.

        O erro comum com literais:
        x = (5)    # Isso é interpretado como um inteiro entre parênteses, não uma tupla!
        y = (5,)   # O jeito correto de criar uma tupla de um item usando literais.

        Usando o construtor com um iterável:
        z = tuple([5]) # Cria corretamente a tupla (5,)

    3) Objetos Range
        a) representa uma sequência imutável de números.
        b) usado frequentemente em loops com for.
        c) pode ser chamado de maneira simples apenas com um argumento.
            Ex: range(3) -> saída: 0, 1, 2
            incrementa de zero até o limite do parâmetro exclusive
        d) poder ser informado o início e fim como parâmetros
            Ex: range(2, 7) -> saída: 2, 3, 4, 5, 6
        e) pode ser passado o início, fim e passo
            Ex: range(2, 9, 3) -> saída: 2, 5, 8

    4) String (tipo especial)
        a) é uma variável do tipo string: pode armazenar
    letras, números, espaços, pontuaçao.
        b) Tratamento de dados textuais
        c) Indexação inicia em 0
        d) Python permite indexação com valores negativos: -1 é o índice do último item
        e) Delimitação de uma string:
            aspas simples: 'string'
            aspas duplas: "string"
            aspas simples triplas: '''string'''
            aspas duplas triplas: """string"""
        f) Métodos para tratamento de string
            - upper: maiúsculas
            Ex: curso = 'Ensino a distância'
                curso.upper() -> 'ENSINO A DISTÂNCIA'
            - lower: minúsculas
                curso.lower() -> 'ensino a distância'
            - split: quebra a string em substrings (cria uma lista)
                curso.split -> ['Ensino', 'a', 'Distância'

    b. Operadores sequenciais comuns
        - Permitem a manipulação de tipos sequenciais, inclusive strings.
    Uso	           Resultado
    x in s	       True se x for um subconjunto de s
    x not in s	   False se x for um subconjunto de s
    s + t	       Concatenação de s e t
    n*s	           Concatenação de n cópias de s
    s[i]	       Caractere de índice i em s
    len(s)	       Comprimento de s
    min(s)	       Menor item de s
    max(s)	       Maior item de s

    c. Dicionários
    - Permitem que itens de uma sequência recebam índices definidos pelo usuário.
    - Contém pares de chave e valor.
    - Sintaxe:
    {<chave 1>:<valor 1>, <chave 2>:<valor 2>, ..., <chave i>:<valor i>}

    - Ex: Poderíamos criar um dicionário em que cada pessoa fosse representada pelo seu CPF,
com nome e sobrenome. Para isso, teríamos o seguinte código:
    pessoas = {'111222335-44':['Jod0','Silva'], '222333444-55':['Maria', 'Santos'], '353444555-66':
['Jorge', 'Silva']}

5. Subprogramas
    - São blocos de código que realizam tarefas específicas dentro um programa maior.
    - Em Python chamamos subprogramas de funções.
    - Define-se uma função com a palavra def, seguida pelo nome da função e
parênteses contendo os parâmetros se houver.
    Ex:
    def diz_ola():
        print("Olá, Mundo!")

6. Parâmetros, procedimentos e funções
    a. Parâmetros

        - Existem duas maneiras para uma função obter os dados:
        -> Acessando variáveis globais
        -> Por passagem de parâmetros quando chamada
        Ex:
        def calculaIMC(peso, altura):
            return peso / (altura ** 2)
        Você chama essa função passando valores específicos para esses parâmetros.
        Que são os argumentos neste caso -> 70, 1.75
        meu_IMC = calculaIMC(70, 1.75)
            print(meu_IMC)

        (1)) Parâmetros formais e reais
        - Formais: são os definidos no cabeçalho da função.
        Ex: peso, altura
        - Reais (argumentos): são os valores que você passa para função.
        Ex: 70, 1.75

        (2) Valores padrão para parâmetros
        - Você pode definir valores padrão para os parâmetros.
        Ex:
        def taximetro(distancia, multiplicador=1):
        ...
        return valor

        pagamento = taximetro(3.5)

        - o parâmetro multiplicador tem um valor padrão de 1.
        - Isso significa que, se não passarmos um valor para multiplicador ao chamar a função, ele usará 1 como padrão.
        - A palavra reservada return indica que a função retorna algum valor.
        - O valor retornado tem que ser armazenado em uma variável -> pagamento.

    c. Procedimentos e funções
        - Procedimentos: não retornam valores.
        - Funções: retornam valores.

    d. Ambientes de referenciamento local
        (1) Variáveis locais
        - Definidas no escopo do subprograma.
        - Tipos:
        Dinâmicas da pilha: são vinculadas ao armazenamento no início
    da execução do subprograma e desvinculada qando este termina.

        Estática: são vinculadas a célula de memória antes do início do
    programa e permanecem vinculadas a esta célula até o final do programa.

        - Todas variáveis locais em Python são dinâmicas da pilha.
        - Para explicitar em um subprograma que a variável é global
    tem que usar a palavra reservada global.
        Ex: global x

    e. Subprogramas aninhados
    - Em Python (e na maioria das linguagens funcionais),
é permitido aninhar subprogramas.

    f. Métodos de passagens de parâmetros
        (1) Valor
         - O parâmetro formal funciona como uma variável local do subprograma,
sendo inicializado com o valor do parâmetro real.
         - não ocorre uma alteração na variável externa ao subprograma
caso ela seja passada como parâmetro.

        (2) Referência
        - Em vez de passar o valor do parâmetro real, é transmitido um caminho de acesso (normalmente,
um endereço de memória) para o subprograma chamado.
        - Ocorre alteração da variável externa ao subprograma.

         (3) O método de passagem de parâmetros do Python é chamado de
 passagem por atribuição.
           - Como todos os valores de dados são objetos,
 toda variável é uma referência para um objeto.
           - podemos entender que a passagem por atribuição é uma passagem por referência,
 pois os valores de todos os parâmetros reais são referências.

 7. Funções recursivas e docstrings
    a. Recursividade
    - a função recursiva é aquela que chama a si mesma.
    Ex:
    def regressiva(x):
       print(x)
       regressiva(x - 1)
    - Porém deve ser definido uma condição de parada
    Ex:
    def regressiva(x):
       if x <= 0:
            print("Acabou")
        else:
            print(x)
            regressiva(x-1)

    b. Documentação de funções - Docstrings
    - Em Python, é possível definir uma string que serve como documentação de
funções definidas pelo desenvolvedor.
    - Ao chamar o utilitário help() passando como parâmetro a função desejada,
essa string é exibida.

8. Importação de funções e módulos
    - Fazer a importação do módulo desejado: import nome_modulo
    - Chamar a função desejada: nome_modulo.nome_função(parâmetros)
    - Exemplos:
        1) math: operações matemáticas
        - sqrt(x): raiz quadrada
        - ceil(x): menor inteiro maior ou igual a x
        - floor(x): maior inteiro menor ou igual a x
        - cos(x): cosseno
        - sin(x): seno
        - log(x, b): logaritmo de x na base b
        - pi: valor de pi
        - e: valor de e

        2) random: gerar números pseudoaleatórios
        - random(): números de ponto flutuante no intervalo(00,0 e 1,0)
        - uniform(a, b): número de ponto flutuante N tal que  a <= N <= b
        - gauss(mu, sigma): distribuição gaussiana
        - normalvariate(mu, sigma): distribuição gaussiana
        - randrange(stop): elemento selecionado aleatório de range(0, stop)
        - randrange(start, stop, step): elemento selecionado aleatório de range(start, stop, step)
        - randint(a, b): número inteiro N tal que a <= N <= b
        - choice(seq): elemnto aleatório de uma sequência
        - shuffle(x[, random]): embaralha a sequência x no lugar
        - sample(pop, k): sequência de tamanho K elementos escolhidos
da população pop, sem repetição.

        3) smtplib: envio de emails
        4) time: implementar contadores temporais
        5) tkinter: desenvolver interfaces gráficas